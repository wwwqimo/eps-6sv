/**
************************************************************************************************************************************
**solar array simulation app
**function     generate solar array data.
**             set the converter output voltage due to the output current referencing the solar array data sheet generated by
**             PVgenerate()
**details      this funtion is called per 1ms,so the output could get a fast response to the loads
**             the pv parameters could be changed by other app.c like uart by changing the pv struct data
**
*************************************************************************************************************************************
*/
#include "app_SolarArraySim.h"


#if USER_DEBUG_EN >0u
#define SAS_DELAY_TIME       2
#else
#define SAS_DELAY_TIME       2
#endif



#define OUTPUT_VOLTAGE_MIN  (float)1.5 //最小输出电压
#define OUTPUT_VOLTAGE_MAX  (float)15.0	//最大输出电压
#define C_DIFF_MIN          (float)0.005//最小电流差
#define V_DIFF_MIN          (float)0.003//最小电压差
extern float Value_Real[]; //换算后真是采样值

//定义电压电流分压或放大倍数
float                   V_Div = 6.36;  //
float                   C_Multi = 1.0;//

//电池片类型数量
//       model_num;
//输出通道数
 //       chan_num;
//电池片曲线数据细分个数
 //    PVdiv_num;	
//声明一个电池片
extern PV_Typedef       PV_model[model_num];
extern PVpara_Typedef   PV_para[model_num];
extern PVnum_Typedef    PV_num[chan_num];


//pid 参数实例化
extern arm_pid_instance_f32     PID_BUCK_SAS_V;
//pid 数据实例化
extern PID_Typedef              PID_BUCK_SAS_var_V;
extern uint16_t                 TIM4_CCR_Val[4];//tim4输出
//定义全局电压电流量，在ADC采集模块通过extern 
//声明之后，在ADC模块内部对其赋值
float V_value[chan_num],C_value[chan_num],R_value[chan_num];
float v_set[chan_num];
static void SAS_PID_Init(void);

void SolarArraySim(void)
{
	uint16_t i,j;
	static uint16_t i_SAS;
//	float v_set[chan_num];
	float pwm_out[chan_num];
	//pid参数初始化；
	SAS_PID_Init();
	
	for (j=0;j<chan_num;j++)
	{
		SAS_EN(j,DISABLE);
	}
	
	#if  USER_SAS_SIM_EN  > 0u
  V_value[0] =7.0f;
//	V_value[1] =9.0f,V_value[2] =12.0f;
	C_value[0] =0.6f;
//	C_value[1] =0.3f,C_value[2] =0.2f;
	R_value[0] = V_value[0]/C_value[0];
//	R_value[1] = V_value[1]/C_value[1];
//	R_value[2] = V_value[2]/C_value[2];
	#endif
	while(1)
	{
#if USER_SAS_EN > 0u
		//对没一个PV模型，若其参数有改动，则进行重新配置，生成新的IV曲线
		for (i=0;i<model_num;i++)
		{
			
			switch (PV_model[i].PVpara.flag)
			{
				//若参数变化则跳转到参数变化分支更改参数，
				//参数修改后顺序执行，修改曲线列表，执行修改后程序
				//若无参数修改出现则只执行程序执行部分
				case 1: //电池片类型参数变化
					
					PV_ChangeType(&PV_model[i],&PV_para[i]);
					//IV_generate(&PV_model[i]);
					//break;
				case 2: //电池片输入条件变化
					PV_ChangeCondition(&PV_model[i],&PV_para[i]);
				  IV_generate(&PV_model[i]);
				  
					#if USER_DEBUG_EN >0u
					bsp_LedOff(2);
					for (j=0;j<PVdiv_num;j++)
					{
						printf("IV_I[%d] %f2\r\n",i,PV_model[i].IV[0][j]);
					}
					printf("PV[%d]->position_prev    %d \r\n",i,PV_model[i].position_prev);
					printf("PV[%d]->position_mppt    %d \r\n",i,PV_model[i].position_mppt);
					printf("PV[%d]->position_nxt     %d \r\n",i,PV_model[i].position_nxt);
					printf("PV[%d]->position_current %d \r\n",i,PV_model[i].position_current);
					bsp_LedOn(2);
					#endif
					if (i == model_num-1)
					{
						for (j=0;j<model_num;j++)
						{
							SAS_EN(j,ENABLE);
						}
					}
				//break;
				case 0:  //无条件变化，执行输出控制程序
					
					break;
				default:
					break;
			}
			
		}
		if (i_SAS++ >= 100)
		{
			i_SAS = 0;

		SolarArraySim_Algorithm(&PV_model[0],&V_value[0], &C_value[0], &PV_num[0]);	

		}
		for (i=0; i<model_num;i++)
		{
			PV_para[i].flag = 0;
			PV_model[i].PVpara.flag = 0;
		}
#endif		
				//ADC_Sample();
	#if USER_SAS_SIM_EN == 0u
		for (i=0;i<chan_num;i++)
		{
			V_value[i] = Value_Real[i]*V_Div;
			C_value[i] = Value_Real[i+3]/C_Multi;
			#if USER_DEBUG_EN >0u
			printf("\r\nV_value[%d] = %f \r\n",i,V_value[i]);
			printf("\r\nC_value[%d] = %f \r\n",i,C_value[i]);
			#endif
		}
	#endif
//		V_value[0] = Value_Real[0]*V_Div;
//		v_set[0] = 12.0f;
		printf("v_value = %2.2f\r\n",V_value[0]);
		PID_BUCK_SAS_var_V.SetValue = v_set[0];
		printf("v_set = %2.2f\r\n",v_set[0]);
		pwm_out[0] = Cal_IncPID(&PID_BUCK_SAS_V, &PID_BUCK_SAS_var_V,V_value[0]);
		printf("pwm_out[0] = %4.2f\r\n",pwm_out[0]);
		TIM4_CCR_Val[2] = (uint16_t)pwm_out[0];
		#if USER_DEBUG_EN >0u
		printf("TIM4 CH3 OUT %4d\r\n",TIM4_CCR_Val[2]);
		#endif
		PWM_Updata(TIM4,TIM4_CCR_Val[0],TIM4_CCR_Val[1],TIM4_CCR_Val[2],TIM4_CCR_Val[3]);
//		
//		PWM_Updata(TIM4,400,200,0,0);
		OSTimeDlyHMSM(0, 0, 0, SAS_DELAY_TIME );	
		
	}
}

static void SAS_PID_Init(void)
{
	PID_BUCK_SAS_V.Kp = 28.5f;
	PID_BUCK_SAS_V.Ki = 0.055f;
	PID_BUCK_SAS_V.Kd = 0.01f;
	
	
	PID_BUCK_SAS_var_V.OutMax = 1000;
	PID_BUCK_SAS_var_V.OutMin = 1;
}
/*
*********************************************************************************************************************************
**确定迭代步长
**     1 由IV 曲线和PV曲线可以看到，IV 曲线前半段近似一条直线，将测量点的电压对应的电流
**      近似为负载曲线和IV曲线交点处电流，因此 该段迭代步长设为1，position_prev之前迭代步长为1
**     2 IV曲线末端曲线近似为一条直线，负载曲线在测量点电流和曲线电流差值较大，若迭代步长过大，则电流
**      设定点将会反方向超调过大，因此迭代步长应该较小。根据负载曲线和IV曲线的形状判断，最后确定的
**      电流差值应该为原始电流差值的（sinx）2，x为曲线末端近似直线和垂直线之间的角度，由于角度较小，
**      以弧度代替sin值。由于sin值和tan值近似，最后以斜率的绝对值替代
**     3 中间部分曲线较复杂，其迭代步长的确定以两端迭代步长数据为基础，由两端的步长组合而成
**      
**
**return 迭代步长
*********************************************************************************************************************************
*/
float SAS_StepSize(PV_Typedef *PV, PVnum_Typedef *PVchan,uint16_t position_value)
{
	float step_size;
	PV_Typedef *_PV;
	static float rate_abs;//末端近似值线斜率绝对值
	static float step_curve1 = 0.6;//曲线1部分迭代步长
	float rate_multi = 0.2f; //曲线2斜率校正参数
	
	_PV =(PV+PVchan->model_type);
	
//	if (_PV->PVpara.flag > 0)//电池片参数改变，则重新计算曲线2斜率
//	{
		rate_abs = rate_multi * sqrt((PVchan->n_s) / (PVchan->n_p));
		if (rate_abs > 0.5f) rate_abs = 0.5f;
		
	  rate_abs *= rate_abs;
		#if USER_DEBUG_EN > 0u
		printf("rate_abs = %f \r\n",rate_abs);
		#endif
//	}
	//曲线1，前段近似值线处迭代步长确定
	if (position_value < _PV->position_prev)
	{
		step_size = step_curve1;
	}
	//曲线2，末端近似值线处迭代步长确定
	else if(position_value > _PV->position_nxt)
	{
		step_size = rate_abs;
	}
	//曲线3，中间部分迭代步长确定
	else
	{
		step_size = rate_abs * (position_value - _PV->position_prev)/(_PV->position_nxt - _PV->position_prev)
		            + step_curve1 * (_PV->position_nxt - position_value)/(_PV->position_nxt - _PV->position_prev);
	}
	#if USER_DEBUG_EN >0u
	printf("step_size of PVchan %f \r\n",step_size);
	#endif
	
	return step_size;
}
/*
*********************************************************************************************************************************
**确定电流值对应在表中的位置
**
**
**return 改点电流值对应于表中的位置
*********************************************************************************************************************************
*/
uint16_t SAS_PositionCurrent(PV_Typedef *PV, float current)
{
	uint16_t position_c;
	return position_c;
}
/*
*********************************************************************************************************************************
**设定电源输出值
**SAS_chan      输出通道选择
**out_value     输出值
**
*********************************************************************************************************************************
*/
void SAS_Setout(float out_value, uint8_t SAS_chan)
{
	#if USER_DEBUG_EN > 0u
	#if USER_SAS_EN > 0u
	V_value[SAS_chan] = out_value;
	C_value[SAS_chan] = V_value[SAS_chan]/R_value[SAS_chan];
	#endif
	#endif
	
//	DAC_Out(out_value, SAS_chan);

	
}
/*
****************************************************************************************************************************
**太阳电池模拟器算法
**根据迭代法 I1 =I0 + L(f(U0)-I0)  
**           其中f(U0)为太阳电池阵的光伏你和曲线
**           L(f(U0)-I0)为迭代步长，L为迭代系数，L越大收敛越快
**reteval   返回设置电压值
**
********************************************************************************************************************************
*/
void SolarArraySim_Algorithm(PV_Typedef *PV,float *v_value, float *c_value, PVnum_Typedef *PVchan)
{
	uint8_t i;
  PV_Typedef *_PV;
	uint16_t point_value, point_set;//测量点位置,设定点位置
	float c_point, c_diff, c_set;//测量点位置对应的曲线电流,电流差值，电流设定值，电压设定值
	float r_load;//负载等效电阻
	float step_size;

	for (i=0;i<chan_num;i++)
	{
		if ((PVchan + i)->model_type > model_num) (PVchan + i)->model_type = 0;
		//获取钙通道对应的PV模型
		_PV = (PV+((PVchan + i)->model_type));
		//确定输出电压处对应在IV[][]表格的位置
		point_value = (uint16_t)(PVdiv_num-1)*((*(v_value + i))/(((PVchan+i)->n_s)*(_PV->PVpara.Voc)));
		if (point_value > PVdiv_num-1) point_value = PVdiv_num-1;
		printf("point value = %4d\r\n",point_value);
		//测量点位置对应的曲线电流
		c_point = ((PVchan+i)->n_p)*(_PV->IV[0][point_value]);
		printf("current point = %1.4f\r\n",c_point);
		//和改点的IV[][]电流值作差
		c_diff =c_point - (*(c_value + i));
		if (abs(c_diff) < C_DIFF_MIN * (PVchan->n_p))
		{
			_PV->position_current = point_value;
		}
		
		//确定迭代步长
		step_size = SAS_StepSize(_PV,(PVchan + i),point_value);
		//确定下一步电流值
		c_set = (*(c_value + i)) + step_size * c_diff;
		//计算负载等效电阻
		r_load = (*(v_value + i)) / (*(c_value + i));
		//求出电压设定点
		v_set[i] = c_set * r_load;
//		if (abs(v_set[i] - *(v_value + i)) < V_DIFF_MIN)
//		{
//			v_set[i] = *(v_value + i);
//		}
		
		//近短路点设置
		if ((v_set[i] < 0.05f * (PVchan+i)->n_s) || (v_set[i] < OUTPUT_VOLTAGE_MIN)) 
		{
			//区两者当中较大的输出
			v_set[i] = (0.05f * ((PVchan+i)->n_s)) > OUTPUT_VOLTAGE_MIN 
								? (0.05f * ((PVchan+i)->n_s)):OUTPUT_VOLTAGE_MIN;
		
		}
		//近开路点设置
		else if ((v_set[i] > ((PVchan+i)->n_s) * (_PV->PVpara.Voc - 0.05f))|| (v_set[i] > OUTPUT_VOLTAGE_MAX))
		{
			//取两者当中较小的输出
			v_set[i] = ((PVchan+i)->n_s) * (_PV->PVpara.Voc - 0.05f) > OUTPUT_VOLTAGE_MAX 
								? OUTPUT_VOLTAGE_MAX : ((PVchan+i)->n_s) * (_PV->PVpara.Voc - 0.05f);
			
		}
		#if  USER_DEBUG_EN >0u
		printf("V_SET[%d] =  %1.4f \r\n",i,v_set[i]);
		#endif
		//设置改点电压输出
		SAS_Setout(v_set[i], i);
	}
	
}


/*************************************************************************************************************************************/
